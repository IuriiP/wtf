<?php

namespace Wtf\Helper;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-06-27 at 10:09:59.
 */
class ComplexTest extends \PHPUnit_Framework_TestCase {

	/**
	 * @var Complex
	 */
	protected $object;

	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 */
	protected function setUp() {
		
	}

	/**
	 * Tears down the fixture, for example, closes a network connection.
	 * This method is called after a test is executed.
	 */
	protected function tearDown() {
		
	}

	/**
	 * @covers Wtf\Helper\Complex::except
	 */
	public function testExcept() {
		// test on wrong types
		$this->assertEmpty(Complex::except('', 0));

		$list = [];
		$black = [];
		$this->assertEmpty(Complex::except($list, $black));

		$list = ['one' => 1, 'two' => 2, 'third' => 3];
		$black = ['two'];
		$this->assertEquals(['one' => 1, 'third' => 3], Complex::except($list, $black));
	}

	/**
	 * @covers Wtf\Helper\Complex::only
	 */
	public function testOnly() {
		// test on wrong types
		$this->assertEmpty(Complex::only('', 5));

		$list = [];
		$white = [];
		$this->assertEmpty(Complex::only($list, $white));

		$list = ['one' => 1, 'two' => 2, 'third' => 3];
		$white = ['two'];
		$this->assertEquals(['two' => 2], Complex::only($list, $white));
	}

	/**
	 * @covers Wtf\Helper\Complex::obj2arr
	 */
	public function testObj2arr() {
		$obj = new \stdClass;
		$obj->one = 'first';
		$obj->two = 'second';
		$obj->three = 'third';

		$this->assertEquals(['one' => 'first', 'two' => 'second', 'three' => 'third'], Complex::obj2arr($obj));

		$obj->complex = ['sub1', 'sub2', 'sub3'];
		$this->assertEquals(['one' => 'first', 'two' => 'second', 'three' => 'third', 'complex' => ['sub1', 'sub2', 'sub3']], Complex::obj2arr($obj));
	}

	/**
	 * @covers Wtf\Helper\Complex::arr2obj
	 */
	public function testArr2obj() {
		$obj = new \stdClass;
		$obj->one = 'first';
		$obj->two = 'second';
		$obj->three = 'third';

		$arr = ['one' => 'first', 'two' => 'second', 'three' => 'third'];

		$this->assertEquals($obj, Complex::arr2obj($arr));
	}

	/**
	 * @covers Wtf\Helper\Complex::arr2ini
	 */
	public function testArr2ini() {
		$arr = [];
		$arr['number'] = 2016;
		$arr['bool'] = false;
		$arr['complex'] = ['first' => 1, 'zero' => 0, 'empty' => null];
		$arr['supercomplex'] = [
			'subcomplex' => [
				'sub2' => 'complex2',
				'sub1' => 1000
			],
			'first' => 1,
			'zero' => 0,
			'empty' => null
		];
		$arr['string'] = 'some text';

		$ini = [];
		$ini[] = 'number=2016';
		$ini[] = 'bool=off';
		$ini[] = 'string=some text';
		$ini[] = '[complex]';
		$ini[] = 'first=1';
		$ini[] = 'zero=0';
		$ini[] = 'empty=null';
		$ini[] = '[complex.supercomplex]';
		$ini[] = 'zero=0';
		$ini[] = 'first=1';
		$ini[] = 'empty=null';
		$ini[] = '[complex.supercomplex.subcomplex]';
		$ini[] = 'sub1=1000';
		$ini[] = 'sub2=complex2';

		$this->assertEquals(implode(PHP_EOL, $ini), Complex::arr2ini($arr));
	}

	/**
	 * @covers Wtf\Helper\Complex::ini2arr
	 */
	public function testIni2arr() {
		$arr = [];
		$arr['number'] = 2016;
		$arr['bool'] = false;
		$arr['complex'] = ['first' => 1, 'zero' => 0, 'empty' => null];
		$arr['supercomplex'] = [
			'subcomplex' => [
				'sub2' => 'complex2',
				'sub1' => 1000
			],
			'first' => 1,
			'zero' => 0,
			'empty' => null
		];
		$arr['string'] = 'some text';

		$ini = [];
		$ini[] = 'number=2016';
		$ini[] = 'bool=off';
		$ini[] = 'string=some text';
		$ini[] = '[complex]';
		$ini[] = 'first=1';
		$ini[] = 'zero=0';
		$ini[] = 'empty=';
		$ini[] = '[supercomplex]';
		$ini[] = 'zero=0';
		$ini[] = 'first=1';
		$ini[] = 'empty=null';
		$ini[] = '[supercomplex.subcomplex]';
		$ini[] = 'sub1=1000';
		$ini[] = 'sub2=complex2';

		$this->assertEquals($arr, Complex::ini2arr(implode(PHP_EOL, $ini)));
	}

	/**
	 * @covers Wtf\Helper\Complex::get
	 */
	public function testGet() {
		$arr = [];
		$arr['number'] = 2016;
		$arr['bool'] = false;
		$arr['empty'] = null;
		$arr['complex'] = ['first' => 1, 'zero' => 0, 'empty' => null];
		$arr['string'] = 'some text';

		$this->assertNull(Complex::get($arr, 'unknown'));
		$this->assertEquals(999, Complex::get($arr, 'unknown', 999));

		foreach($arr as $key => $val) {
			$this->assertEquals($val, Complex::get($arr, $key));
		}
	}

	/**
	 * @covers Wtf\Helper\Complex::eliminate
	 */
	public function testEliminate() {
		$arr = [];
		$arr['number'] = 2016;
		$arr['bool'] = false;
		$arr['empty'] = null;
		$arr['complex'] = ['first' => 1, 'zero' => 0, 'empty' => null];
		$arr['string'] = 'some text';

		$clone = $arr;

		$this->assertNull(Complex::eliminate($clone, 'unknown'));
		$this->assertEquals($arr, $clone);

		$this->assertEquals(2016, Complex::eliminate($arr, 'number'));
		unset($clone['number']);
		$this->assertEquals($arr, $clone);
	}

	/**
	 * @covers Wtf\Helper\Complex::arr2attr
	 */
	public function testArr2attr() {
		$arr = [];
		$arr['number'] = 2016;
		$arr['bool'] = false;
		$arr['empty'] = null;
		$arr['string'] = 'some text';

		$expect = [
			'number="2016"',
			'bool="off"',
			'empty',
			'string="some text"',
		];

		$this->assertEquals($expect, Complex::arr2attr($arr));

		$expect = [
			'number="2016"',
			'string="some text"',
		];

		$this->assertEquals($expect, Complex::arr2attr($arr, ['number', 'string']));
	}

	/**
	 * @covers Wtf\Helper\Complex::attr2arr
	 */
	public function testAttr2arr() {
		$xml = <<<EOT
<?xml version='1.0' standalone='yes'?>
<root><node first="one" second="two" /></root>
EOT;

		$doc = new \DOMDocument();
		$doc->loadXML($xml);

		$expect = [
			'first' => 'one',
			'second' => 'two',
		];

		$this->assertEquals([], Complex::attr2arr($doc->documentElement));
		$this->assertEquals($expect, Complex::attr2arr($doc->documentElement->firstChild));

		$sxe = new \SimpleXMLElement($xml);
		$this->assertEquals([], Complex::attr2arr($sxe));
		$this->assertEquals($expect, Complex::attr2arr($sxe->node));

		$this->assertNull(Complex::attr2arr(null));
		$this->assertNull(Complex::attr2arr(new \stdClass()));
	}

	public function testXmlEncode() {
		$array = [
			'@attr' => 'some',
			[
				'first' => 'one',
				'second' => 'two',
			],
			[
				'third' => 'three',
				'repeat' => [
					1, ['@att' => 'att', 2], 3, 4,
				],
			],
		];
		$xml = <<<EOT
<?xml version='1.0' standalone='yes'?>
<xml attr="some">
<node>
	<first>one</first>
	<second>two</second>
</node>
<node>
	<third>three</third>
	<repeat>1</repeat>
	<repeat att="att">2</repeat>
	<repeat>3</repeat>
	<repeat>4</repeat>
</node>
</xml>
EOT;

		$sxe = new \SimpleXMLElement($xml);
		$encoded = Complex::arr2xml($array);
		$this->assertEqualXMLStructure(dom_import_simplexml($sxe), dom_import_simplexml($encoded));
	}

	public function testXmlDecode() {
		$array = [
			'@attr' => 'some',
			'node' => [[
				'first' => 'one',
				'second' => 'two',
				],
				[
					'third' => 'three',
					'repeat' => [
						1, 2.3, 3, 4,
					],
				],
			]
		];
		$xml = <<<EOT
<?xml version='1.0' standalone='yes'?>
<xml attr="some">
<node>
	<first>one</first>
	<second>two</second>
</node>
<node>
	<third>three</third>
	<repeat>1</repeat>
	<repeat>2.3</repeat>
	<repeat>3</repeat>
	<repeat>4</repeat>
</node>
</xml>
EOT;

		$sxe = new \SimpleXMLElement($xml);
		echo $sxe->asXML();
		$decoded = Complex::xml2arr($sxe);
		$this->assertEquals($array, $decoded);
	}

}
