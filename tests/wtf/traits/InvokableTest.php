<?php

namespace Wtf\Traits;

class InvokableMock implements \Wtf\Interfaces\Invokable {

	use Invokable;
}

class Invokable_ArrayMock implements \Wtf\Interfaces\Invokable, \ArrayAccess {

	use Invokable;

	private $_array = [];

	public function offsetExists($offset) {
		return isset($this->_array[$offset]);
	}

	public function offsetGet($offset) {
		return isset($this->_array[$offset]) ? $this->_array[$offset] : null;
	}

	public function offsetSet($offset, $value) {
		$this->_array[$offset] = $value;
	}

	public function offsetUnset($offset) {
		unset($this->_array[$offset]);
	}

}

class Invokable_CallerMock implements \Wtf\Interfaces\Invokable, \Wtf\Interfaces\Caller {

	use Invokable;

	public function __call($name, $arguments) {
		return ["call_{$name}" => $arguments];
	}

	public static function __callStatic($name, $arguments) {
		return ["callStatic_{$name}" => $arguments];
	}

}

/**
 * Generated by PHPUnit_SkeletonGenerator on 2017-02-10 at 16:59:13.
 */
class InvokableTest extends \PHPUnit_Framework_TestCase {

	/**
	 * @var Invokable
	 */
	protected $object;

	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 */
	protected function setUp() {
		
	}

	/**
	 * Tears down the fixture, for example, closes a network connection.
	 * This method is called after a test is executed.
	 */
	protected function tearDown() {
		
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 */
	public function test__invokeArray() {
		$obj = new Invokable_ArrayMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj['foo'] = 'bar';
		$obj['baz'] = [
			'quux' => [
				'qooox' => 'qwwwwwx'
			]
		];
		$this->assertEquals('bar', $obj('foo'));
		$this->assertEquals('qwwwwwx', $obj('baz', 'quux', 'qooox'));
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 */
	public function test__invokeArrayAccess() {
		$obj = new Invokable_ArrayMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj['foo'] = 'bar';
		$this->assertEquals('bar', $obj('foo'));
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 */
	public function test__invokeGetter() {
		$obj = new InvokableMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj->foo = 'bar';
		$this->assertEquals('bar', $obj('foo'));
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 */
	public function test__invokeCall() {
		$obj = new InvokableMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj->foo = new Invokable_CallerMock();
		$this->assertEquals([
			'call_bar' => ['baz']
			], $obj('foo', 'bar', 'baz'));
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 * @expectedException ErrorException
	 * @expectedExceptionMessage Method 'Wtf\Traits\InvokableMock::uux' not available
	 */
	public function test__invokeArgsError1() {
		$obj = new InvokableMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj->foo = [
			'bar' => 'baz'
		];
		$this->assertEquals('baz', $obj('foo', 'bar'));
		$obj('foo', 'uux');
	}

	/**
	 * @covers Wtf\Traits\Invokable::__invoke
	 * @expectedException ErrorException
	 * @expectedExceptionMessage Method 'Wtf\Traits\InvokableMock::bar' not available
	 */
	public function test__invokeArgsError2() {
		$obj = new InvokableMock();

		$this->assertInstanceOf(\Wtf\Interfaces\Invokable::class, $obj);

		$obj->foo = new InvokableMock();
		$obj('foo', 'bar');
	}

}
